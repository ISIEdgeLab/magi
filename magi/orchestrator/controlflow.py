import logging
import string
import sys 
from collections import defaultdict
import pdb

logging.basicConfig(level=logging.INFO)
log = logging.getLogger()

class ControlGraph(object):
    """ Create the call graph from the procedure description 
    """
    def __init__(self):
        ''' Initialize a control graph for display'''
        self.controlgraph = dict() 
        self.keys = list()
        self.graphEdges = list()
        self.graphNodes = list()
        self.graphIntriggers = defaultdict(set)
        self.graphOuttriggers = defaultdict(set)

        # Currently etup and exit nodes are represented at singleton events 
        pdb.set_trace()
        self.addCompositeCluster('setup')
        self.addCompositeCluster('exit')
        self.addCompositeCluster('env')

        # Always show the setup node 
        self.show= list()
        self.show.append('setup')

    def addCompositeCluster(self,type):
        self.createCluster(type)
        self.controlgraph[type].addEvent(event=None,addlabel=string.upper(type))  

    def createCluster(self,key):
        self.keys.append(key)
        self.controlgraph[key] = ControlGraphCluster(key) 

    def writepng(self):
        import pydot 
        # TODO: walk through the controlgraph 
        # keys. if key is setup or exit add node
        # else add cluster and send to graphcluster to populate 
        cpng = pydot.Dot(graph_type = 'digraph', fontname="Verdana")
        for k in self.keys:
            if k == 'setup' or k == 'exit' or k == 'env':
                if k in self.show:
                    cpng.add_node(pydot.Node(self.controlgraph[k].nodes[0]['id'],
                                         label = self.controlgraph[k].nodes[0]['label']))
            else:
                c = pydot.Cluster(k, label=k)

                allnodes = self.controlgraph[k].getAllNodes()
                for n in allnodes:
                    if n['type'] != 'syncnode':
                        c.add_node(pydot.Node(n['id'], label=n['label']))

                cpng.add_subgraph(c)

                alledges = self.controlgraph[k].getAllEdges()
                for e in alledges:
                    cpng.add_edge(pydot.Edge(e['from'], e['to'], label=e['label']))
                print self.controlgraph[k].otriggers
                print self.controlgraph[k].itriggers

        for e in self.graphEdges:
            cpng.add_edge(pydot.Edge(e['from'], e['to'], label=e['label']))

        cpng.write_raw('test.dot')
        cpng.write_png('test.png')



    def finishControlgraph(self):
        # if addEvent edge to node exisits otherwise add external node to sink edge 
        # if addTrigger edge from node exisits otherwise add external node generating
        for k in self.keys:
            #pdb.set_trace()
            if k == 'setup' or k == 'exit' or k =='env':
                continue
            # Todo: stoppped here 
            # InTriggers: event [set of nodes waiting for the event ] , event: [ set of nodes waiting for event] .... 
            # OutTriggers: Targetstream: [ set of nodes that connect to target] , triggerEvent: [ set of nodes that generate event] 
            self.graphIntriggers = self.addIntraClusterTriggers(self.controlgraph[k].itriggers,self.graphIntriggers)
            self.graphOuttriggers = self.addIntraClusterTriggers(self.controlgraph[k].otriggers,self.graphOuttriggers)

        pdb.set_trace()
        # Add intraCluster Edges
        # Todo: 
        # here start with stuff from the outtrigger 
        edgeid = 0 
        print "All OutTriggers:" , self.graphOuttriggers
        print "All InTriggers:" , self.graphIntriggers 
        if 'exit' in self.graphOuttriggers:
            self.show.append('exit')

        for gentrigger in self.graphOuttriggers:
            print gentrigger
            if gentrigger in self.graphIntriggers:
                # Found a set of nodes that are waiting for this event 
                # Now connect to these two nodes together 
                while len(self.graphOuttriggers[gentrigger]) > 0: 
                    nodefrom = self.graphOuttriggers[gentrigger].pop()
                    while len(self.graphIntriggers[gentrigger])>0:
                            nodeto = self.graphIntriggers[gentrigger].pop()
                            self.addIntraEdge(nodefrom,nodeto,edgeid,gentrigger)
                            edgeid += 1
                            # All nodes now have incoming edges for this trigger 
                            # Remove the occurange in the intrigger list 
                            if len(self.graphIntriggers[gentrigger]) == 0:
                                del self.graphIntriggers[gentrigger]

                # Did not find a set of nodes waiting for the event generated by this node. :( 
                # send the event to the environment

            else:
            # check is there is a stream by that name 
                if gentrigger in self.keys:
                    while len(self.graphOuttriggers[gentrigger]) > 0:
                        nodefrom = self.graphOuttriggers[gentrigger].pop()
                        self.addIntraEdge(nodefrom,self.controlgraph[gentrigger].nodes[0]['id'],edgeid,"Jump")
                        edgeid += 1
                else:
                    while len(self.graphOuttriggers[gentrigger]) > 0:
                        nodefrom = self.graphOuttriggers[gentrigger].pop()
                        if "Trigger" in nodefrom:
                            # No target by that name. jumping to some place in the environment
                            log.critical("Trying to jump to target %s, but it does not exist", gentrigger)
                        else:
                            # This is an event generated by a method that the orchestrator is not waiting on 
                            self.show.append('env')
                            self.addIntraEdge(nodefrom,self.controlgraph['env'].nodes[0]['id'],edgeid,gentrigger)
                            edgeid += 1


        #if len(self.graphOuttriggers) > 0:
        #    log.critical("this should not happen")
        pdb.set_trace()
        if len(self.graphIntriggers) > 0:
            # These are triggers coming in from the env
            self.show.append('env')
            for intrigger in self.graphIntriggers:
                while len(self.graphIntriggers[intrigger]) > 0:
                    nodeto = self.graphIntriggers[intrigger].pop()
                    self.addIntraEdge(self.controlgraph['env'].nodes[0]['id'],nodeto,edgeid,intrigger)
                    edgeid += 1 
            


    def addIntraEdge(self,fromNode,toNode,id,label=" "):
        # Outgoing trigger from Eventstream 
        # Hence edge has the event key in the name 
        tempedge = dict()
        tempedge['id'] = 'Edge' + str(id) 
        tempedge['type'] = 'edge'
        tempedge['label'] = label 
        tempedge['from'] = fromNode
        tempedge['to'] = toNode 
        self.graphEdges.append(tempedge)


    def addIntraClusterTriggers(self,src,dst):
        for event in src:
            if event not in dst:
                dst[event]=set()
            for nodewaiting in src[event]:
                dst[event].add(nodewaiting)
        return dst

    def finishCluster(self,key):
        self.addEdges(key)
        # if triggerlist, need to add proper edges from parent event
        

    def addEdges(self,key):
        self.controlgraph[key].addEdges()
        pass

    def addEvent(self,key,event):
        self.controlgraph[key].addEvent(event)

    def addTrigger(self,key,event):
        self.controlgraph[key].addTrigger(event)

    def __repr__(self):
        rstr = "Control Graph\n" 
        for k, v in self.controlgraph.items():
            rstr = rstr + str(k) + "\n" + v.__repr__()+ "\n"
        return rstr 

class ControlGraphCluster(dict):
    """ Creates a cluster of connected control graph nodes  
    """

    def __init__(self,key):
        self.key = key
        self.otriggers = defaultdict(set) 
        self.itriggers = defaultdict(set) 
        self.nodes = list()
        self.edges = list()


    def getAllTriggers(self, str):
        if 'str' == 'in':
            return self.itriggers
        else:
            return self.otriggers

    def getNodeIndex(self):
        return str(len(self.nodes))

    def getAllNodes(self):
        return self.nodes 

    def getEdgeIndex(self):
        return str(len(self.edges))

    def getAllEdges(self):
        return self.edges

    def addEvent(self,event=None,addlabel=None):
        print "adding node", event 
        tempnode = dict()
        tempnode['type'] = 'node'
        tempnode['id']= str(self.key) + "Event" + self.getNodeIndex() 
        tempnode['edgeto']= set()
        # Create the label 
        if addlabel:
            label = addlabel
        else:
            label = "Send" 
        # TODO: write send method to agent format using getkey 
        if event:
            for k,v in event.items():
                if k == 'trigger':
                    tempnode['edgeto'].add(v) 
                    self.otriggers[v].add(tempnode['id']) 
                    continue
                if k == 'args' or k == 'execargs' or k == 'type':
                    continue 
                label = label + "\n" + str(k) + ":" + str(v)

        tempnode['label'] = label 
        self.nodes.append(tempnode)
                
    def addEdges(self):
        prevnodes = list() 
        #TODO: need to get the id from the setup cluster. yikes right now it is hardcoded 
        prevnodes.append('setupEvent0')

        currentnodes = list() 
        # index into nodes 
        j = 0 
        lenNodes = len(self.nodes)

        # Add the straight edges 
        while True:
            #pdb.set_trace()
            hasTarget = list()
            if 'Event' in self.nodes[j]['id']:
                currentnodes.append(self.nodes[j]['id'])
                j += 1
            else:
                if 'StartTList' in self.nodes[j]['id']: 
                    # Ignore the syncnode 
                    j += 1
                    if len(self.nodes[j]['edgeto']) != 0:
                        hasTarget.append(len(currentnodes)) 
                    currentnodes.append(self.nodes[j]['id'])
                    j += 1
                    while not 'EndTList' in self.nodes[j]['id']:
                        if len(self.nodes[j]['edgeto']) != 0:
                            hasTarget.append(len(currentnodes))
                        currentnodes.append(self.nodes[j]['id'])
                        j += 1
                    # Ignore the syncnode 
                    j += 1

            print self.key 
            print "prev:", prevnodes
            print "cur:", currentnodes
            print hasTarget
        
            # This code does not have the data you need 
            for pnode in prevnodes:
                for cnode in currentnodes:
                    tempedge = dict()
                    tempedge['id'] = str(self.key) + 'Edge' + self.getEdgeIndex()
                    tempedge['type'] = 'edge'
                    tempedge['label'] = " " 
                    tempedge['to'] =  cnode
                    tempedge['from'] = pnode
                    self.edges.append(tempedge)


            if j >= lenNodes:
                print "ERROR: node index exceeds event index" 
                break

            # Create the prevnodes list based on nodes that 
            # do not have a target 
            prevnodes = list()
            for i,cnode in enumerate(currentnodes):
                if i not in hasTarget:
                    prevnodes.append(cnode)
            currentnodes = list() 


    def addOneEdge(self,fromNode,toNode,label=" "):
        # Outgoing trigger from Eventstream 
        # Hence edge has the event key in the name 
        tempedge = dict()
        tempedge['id'] = str(self.key) + 'Edge' + self.getEdgeIndex()
        tempedge['type'] = 'edge'
        tempedge['label'] = label 
        tempedge['from'] = fromNode
        tempedge['to'] = toNode 
        self.edges.append(tempedge)

    def addTrigger(self,trigger):
        print "adding trigger", trigger 
        # A Trigger is a list of TriggerData
        # We parse each trigger and see which one arrives and decides the control 
        # path 
        
        # Add triggerlist ends in the node list to indicate start and end of 
        # the trigger list #
        # This significantly simpliies adding and managing the links during 
        # fanin and fanout  
        tempnode = dict()
        tempnode['type'] = 'syncnode'
        tempnode['id'] = 'StartTList'
        self.nodes.append(tempnode)

        for i, l in enumerate(trigger):
            label = ""
            fesets = l.getEsets()
            tempnode = dict()
            tempnode['type'] = 'node' 
            tempnode['id'] = str(self.key) + "Trigger"+ self.getNodeIndex() + str(i)
            tempnode['edgefrom']=set()
            tempnode['edgeto']=set()
            ed  = l.getArgs()
            ec = l.getCount()
            es = l.getSets()
            waitforEvent = "" 
            if ed.get('event'):
                waitforEvent = ed.get('event')
                # if this is a trigger waiting from an event then we set the 
                # id with the event name 
                label = 'event: ' + str(waitforEvent) 
                #tempnode['id'] = 'Trigger' + str(waitforEvent)
                tempnode['edgefrom'].add(waitforEvent)
                self.itriggers[waitforEvent].add(tempnode['id'])
            if l.target:
            # These targets are eventstreams 
            # Hence we can directly add a edge here 
                tempnode['edgeto'].add(l.target)
                self.otriggers[l.target].add(tempnode['id'])
            if ec != 1:
                label = label + "\n" + "count: " + str(ec) 
                #pdb.set_trace()
            for k,v in ed.items():
                if k != 'event':
                    label = label + "\n" + str(k) + ": " + str(v) 
            if es:
                first=True
                for kes,ves in es.items():
                    if first is False:
                            label = label + "AND\n"
                    label = label + str(kes) + ":" + str(ves) + "\n"
                    first = False 
            if fesets:
                first=True
                for k,v in fesets.items():
                    ed=v.getArgs() 
                    if first is False:
                            label = label + "AND\n"
                    for edk, edv in ed.items():
                        label = label + str(edk) + ": " + str(edv) + "\n" 
                        if edk == 'event':
                            self.itriggers[edv].add(tempnode['id'])
                            tempnode['edgefrom'].add(edv)
                        first = False 
                    if v.getCount() != 1:
                        label = label + "\n" + "count: " + v.getCount() 

            if l.timeout == sys.maxint:
                label  = "Wait for \n" + label 
            elif l.timeout is not None:
                if label:
                    label  = "Wait " + str(l.timeout/1000) + "s " + "for \n" + label
                else:
                    label  = "Wait " + str(l.timeout/1000) + "s "

            tempnode['label'] = label 
            print tempnode 
            self.nodes.append(tempnode)

        tempnode = dict()
        tempnode['type'] = 'syncnode'
        tempnode['id'] = 'EndTList'
        self.nodes.append(tempnode)


    def __repr__(self):
        rstr = "Cluster Graph: " + self.key + "\n"
        for n in self.nodes:
            for k,v in n.items():
                rstr = rstr +  " " + str(k) + ':' + str(v) +"\n" 
            rstr += "\n"
        for e in self.edges:
            for k,v in e.items():
                rstr = rstr +  " " + str(k) + ':' + str(v) +"\n" 
            rstr += "\n"
        return rstr 


# locally parse AAL file-$                                                     
if __name__ == "__main__":
    optparser = optparse.OptionParser()
    optparser.add_option("-f", "--file", dest="file", help="AAL Events file", default=[], action="append")
    (options, args) = optparser.parse_args()

    x = AAL(files=options.file, dagdisplay=True)
    print "Incoming Event triggers", x.ieventtriggers
    print "Outgoing Event triggers", x.oeventtriggers
    print x.__repr__()


